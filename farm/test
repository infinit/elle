#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import io
import os
import re
import sys
import stat
import copy
import html
import time
import email
import runpy
import pprint
import argparse
import datetime
import threading
import email.mime
import smtplib as sml
import subprocess as sp

from higgs import pool
from higgs import infinitools
from higgs import watchers
from higgs.watchers import StatusCode
from collections import namedtuple
from collections import OrderedDict

pattern = re.compile(r"^(?P<name>.*)\.(?P<nb>\d+)\.(?P<ext>py|sh)$")

import platform

os.environ['INFINIT_RANDOM_SOURCE'] = '/dev/urandom'

BUILD = os.environ.get(
    'DIR_BUILD',
    os.path.join(
        os.path.abspath(os.path.dirname(__file__)),
        '../build/',
        platform.system().lower() + platform.architecture()[0][:2]
    )
)

SOURCE = os.environ.get(
    'DIR_SOURCE',
    os.path.join(
        os.path.abspath(os.path.dirname(__file__)),
        '../source/'
    )
)

WATCHERS = (
        watchers.Timing,
        watchers.Environ,
        watchers.Result,
        watchers.Memory,
        watchers.Graph,
    )


def launch_script(engine, script_report, script_path, script_name, nb_instance):
    script_report["Script path"] = script_path

    # Skip the script if it's not executable
    if not os.stat(script_path)[stat.ST_MODE] & stat.S_IXUSR:
        script_report["Error"] = "The script is not executable"
        script_report["result"] = "FAILURE"
        return

    script_report["Number of peers"] = nb_instance

    print("launch the test [\033[32m", script_path,
            "\033[0m] with",
            nb_instance, "instances")
    homes = {}
    with pool.Pool(engine, number_of_networks=nb_instance) as p:

        # Fill the report for the networks used by the script
        script_report["home"] = OrderedDict()
        home_report = script_report["home"]

        for i, H in enumerate(p.l_home):
            home_report["home[{0}]".format(i)] = OrderedDict()
            curr_rep = home_report["home[{0}]".format(i)]
            curr_rep["home"] = H.home
            curr_rep["user"] = H.user
            curr_rep["conf"] = H.conf.to_dict()
            curr_rep["network"] = H.network
            curr_rep["mode"] = H.mode

            # Dump the .set files
            with open(os.path.join(
                    H.home,
                    "networks",
                    H.network,
                    "{net}.set".format(net=H.network)), "r") \
            as setfile:
                curr_rep["set"] = setfile.read().split()


        # Prepare the Watchers for this test
        watchers = list(type_(script_name, report["scripts"]) for type_ in WATCHERS)

        # Save the environ to add some stuff inside
        environ_save = copy.deepcopy(os.environ)

        # Wait for the mountpoints to be ready
        p.wait_ready()
        print("\033[32mAll the filesystems are effectivly mounted, start the testing...\033[0m")

        # The scripts needs MNT$i variables to point to the
        # mountpoints
        for (i, mountpoint) in enumerate(p.mountpoints):
            os.environ["MNT{0}".format(i + 1)] = mountpoint
            print("export MNT{0}={1}".format(i + 1, mountpoint))

        for (i, pid) in enumerate(p.pids):
            os.environ["INFINIT_PID{0}".format(i + 1)] = str(pid)

        for w in watchers:
            w.pre_run(os.environ)

        s = StatusCode()

        out = ""
        try:
            p1 = sp.Popen([script_path], stdout=sp.PIPE, stderr=sp.STDOUT)
            out, _ = p1.communicate()
            if p1.returncode == 0:
                    s.status = StatusCode.SUCCESS
                    print("\033[32mtest", script_name,"success\033[0m")
            else:
                    s.status = StatusCode.FAILURE
                    print("\033[31mtest", script_name,"failed\033[0m")
        except BaseException as e:
            s.status = StatusCode.FAILURE
            print(e)
            script_report["Reason"] = str(e)
            print("\033[31mtest", script_name, "failed\033[0m")
        finally:
            import html
            if "std" not in script_report:
                script_report["std"] = OrderedDict()
            if out:
                script_report["std"]["out"] = html.escape(out.decode("utf8"))
            else:
                script_report["std"]["out"] = ""
            for w in watchers:
                w.post_run(s)
    for w in watchers:
        w.post_shutdown(report)
    for r, stderr in zip(home_report.values(), p.stderrs):
        r['output'] = html.escape(stderr.read().decode('utf8'))
    os.environ = environ_save
    return watchers

def launch_scripts(engine, scriptdir, report, scripts_to_run):
    for root, dirs, scripts in os.walk(scriptdir):
        for script in scripts:
            m = pattern.match(script)
            if m == None:
                continue

            script_data = m.groupdict()

            nb_instance = int(script_data["nb"])
            script_name = script_data["name"]

            if scripts_to_run != None and not script_name in scripts_to_run:
                continue

            report["scripts"][script_name] = OrderedDict()
            script_report = report["scripts"][script_name]

            script_path = os.path.join(root, script)

            launch_script(engine, script_report, script_path, script_name, nb_instance)

def functionals_tests(scriptdir, report, scripts_to_run=None):
    import pprint
    print("functionals_tests working on", scriptdir, ",\n".join(os.listdir(scriptdir)))
    with pool.PoolEngine(low_port=5656, high_port=5660) as engine:
        report["engine"] = OrderedDict()
        engine_report = report["engine"]
        report["scripts"] = OrderedDict()

        # Fill the engine report
        engine_report["home"] = engine._base.home
        engine_report["user"] = engine._base.user
        engine_report["mode"] = engine._base.mode
        engine_report["network"] = engine._base.network
        engine_report["conf"] = engine._base.conf.to_dict()

        os.environ["PYTHONPATH"] = scriptdir
        launch_scripts(engine, scriptdir, report, scripts_to_run)
    return all(test["result"] == "SUCCESS" for test in report["scripts"].values())

def unit_tests(report):
    report["unit_tests"] = OrderedDict()
    ret = True
    out, err = "", ""
    try:
        s1 = sp.Popen(["make", "test"], cwd=BUILD, stdout=sp.PIPE, stderr=sp.STDOUT)
        out, err = s1.communicate()
        print(out.decode("utf8"))
        report["unit_tests"]["result"] = "SUCCESS"
    except Exception as e:
        print(e)
        report["unit_tests"]["result"] = "FAILURE"
        ret = False
    finally:
        import html
        report["unit_tests"]["stdout"] = html.escape(out.decode("utf8"))
    return ret

def clean_the_fuck_up():
    """
    For some reasons, infinit does not clean itself correctly.

    We know that we create the dirs in /tmp/infinit.*
    """

    # Shut the fuck up
    sp.call(['sudo', 'pkill', '-9', '8infinit'])

    mount_p = sp.Popen(['sudo', 'mount',
        '-t', 'fuse.infinit'], stdout=sp.PIPE)

    cut_p = sp.Popen(['cut',
        '-d', ' ',
        '-f', '3'], stdin=mount_p.stdout, stdout=sp.PIPE)
    mount_p.stdout.close()
    mountpoints = cut_p.communicate()[0].split()
    if mountpoints:
        sp.call([b'sudo', b'umount'] + mountpoints)
    sp.call('rm -rf /tmp/infinit.*', shell=True)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run the infinit test suite")

    parser.add_argument('--scriptdir', '-d', metavar="DIR",
            default=os.path.join(SOURCE, "tests", "functional", "scripts"),
            help="the dir containing the scripts to be run")

    parser.add_argument('--scripts', '-s',
            help="the scripts to be run")

    parser.add_argument('--sendmail', '-M', action="store_true",
            help="send a mail")

    parser.add_argument('--source ', '-r', default=SOURCE,
            help="the source directory")

    parser.add_argument('--builddir', '-b', default=BUILD,
            help="the build directory containing the binaries")

    parser.add_argument('--no-unit', action="store_true", default=False,
            help="do not run the unit tests")

    args = parser.parse_args()

    # Update the env and paths for compatibility purpose
    os.environ["INFINIT_BUILD"] = args.builddir
    infinitools.patch_satellites_path(args.builddir)

    functional_success = False
    unit_success = False
    report = OrderedDict()
    # Run the functionals tests
    if not args.scripts:
        functional_success = functionals_tests(args.scriptdir, report)
    else:
        functional_success = functionals_tests(args.scriptdir, report, args.scripts.split(","))

    # Run the unit tests (if no script was specified explicitly)
    if not args.scripts and not args.no_unit:
        unit_success = unit_tests(report)
    else:
        unit_success = True

    with open("report", "w") as reportfile:
        import pprint
        pprint.pprint(report, stream=reportfile)

    if args.sendmail:
        m = watchers.Mail()
        m.send_mail(report)

    if functional_success == False \
        or unit_success == False:
        sys.exit(1)
